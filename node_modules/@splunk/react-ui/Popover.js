/******/ (() => {
    // webpackBootstrap
    /******/ "use strict";
    /******/ // The require scope
    /******/    var e = {};
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/    (() => {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ e.n = t => {
            /******/ var r = t && t.__esModule ? 
            /******/ () => t["default"]
            /******/ : () => t
            /******/;
            e.d(r, {
                a: r
            });
            /******/            return r;
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/define property getters */
    /******/    (() => {
        /******/ // define getter functions for harmony exports
        /******/ e.d = (t, r) => {
            /******/ for (var n in r) {
                /******/ if (e.o(r, n) && !e.o(t, n)) {
                    /******/ Object.defineProperty(t, n, {
                        enumerable: true,
                        get: r[n]
                    });
                    /******/                }
                /******/            }
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/    (() => {
        /******/ e.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)
        /******/;
    })();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/    (() => {
        /******/ // define __esModule on exports
        /******/ e.r = e => {
            /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                /******/ Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                });
                /******/            }
            /******/            Object.defineProperty(e, "__esModule", {
                value: true
            });
            /******/        };
        /******/    })();
    /******/
    /************************************************************************/    var t = {};
    // ESM COMPAT FLAG
        e.r(t);
    // EXPORTS
        e.d(t, {
        PopoverContext: () => /* reexport */ $,
        default: () => /* reexport */ Ze
    });
    // CONCATENATED MODULE: external "react"
    const r = require("react");
    var n =  e.n(r);
    // CONCATENATED MODULE: external "prop-types"
    const o = require("prop-types");
    var a =  e.n(o);
    // CONCATENATED MODULE: external "react-dom"
    const i = require("react-dom");
    // CONCATENATED MODULE: external "lodash/clamp"
    const l = require("lodash/clamp");
    var c =  e.n(l);
    // CONCATENATED MODULE: external "lodash/defer"
    const f = require("lodash/defer");
    var s =  e.n(f);
    // CONCATENATED MODULE: external "lodash/every"
    const u = require("lodash/every");
    var p =  e.n(u);
    // CONCATENATED MODULE: external "lodash/has"
    const h = require("lodash/has");
    var d =  e.n(h);
    // CONCATENATED MODULE: external "lodash/includes"
    const v = require("lodash/includes");
    var m =  e.n(v);
    // CONCATENATED MODULE: external "lodash/intersection"
    const b = require("lodash/intersection");
    var y =  e.n(b);
    // CONCATENATED MODULE: external "lodash/isFinite"
    const g = require("lodash/isFinite");
    var w =  e.n(g);
    // CONCATENATED MODULE: external "lodash/isFunction"
    const S = require("lodash/isFunction");
    var O =  e.n(S);
    // CONCATENATED MODULE: external "lodash/keys"
    const P = require("lodash/keys");
    var E =  e.n(P);
    // CONCATENATED MODULE: external "lodash/omit"
    const C = require("lodash/omit");
    var j =  e.n(C);
    // CONCATENATED MODULE: external "lodash/throttle"
    const k = require("lodash/throttle");
    var x =  e.n(k);
    // CONCATENATED MODULE: external "@splunk/themes"
    const A = require("@splunk/themes");
    // CONCATENATED MODULE: external "@splunk/react-ui/Animation"
    const T = require("@splunk/react-ui/Animation");
    // CONCATENATED MODULE: external "@splunk/react-ui/EventListener"
    const R = require("@splunk/react-ui/EventListener");
    var q =  e.n(R);
    // CONCATENATED MODULE: external "@splunk/react-ui/Layer"
    const W = require("@splunk/react-ui/Layer");
    var M =  e.n(W);
    // CONCATENATED MODULE: external "@splunk/react-ui/ScrollContainerContext"
    const H = require("@splunk/react-ui/ScrollContainerContext");
    var _ =  e.n(H);
    // CONCATENATED MODULE: external "@splunk/ui-utils/focus"
    const L = require("@splunk/ui-utils/focus");
    // CONCATENATED MODULE: ./src/Popover/getPlacement.ts
    function D(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            if (t) n = n.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            }));
            r.push.apply(r, n);
        }
        return r;
    }
    function I(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = arguments[t] != null ? arguments[t] : {};
            if (t % 2) {
                D(Object(r), true).forEach((function(t) {
                    F(e, t, r[t]);
                }));
            } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(e, Object.getOwnPropertyDescriptors(r));
            } else {
                D(Object(r)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
                }));
            }
        }
        return e;
    }
    function F(e, t, r) {
        if (t in e) {
            Object.defineProperty(e, t, {
                value: r,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            e[t] = r;
        }
        return e;
    }
    function N(e) {
        var t = e.align, r = e.anchorPos, n = e.outerContainerEl, o = e.padding, a = e.placement;
        switch (a) {
          case "above":
            return {
                top: r.top - n.offsetHeight,
                left: t === "edge" ? r.left - o : r.middle - n.offsetWidth / 2
            };

          case "below":
            // Align 'end' is only supported by below
            // TODO: SUI-5101 Enable users to align Popover and Dropdown
            if (t === "end") {
                return {
                    top: r.bottom,
                    left: r.right - n.offsetWidth + o
                };
            }
            return {
                top: r.bottom,
                left: t === "edge" ? r.left - o : r.middle - n.offsetWidth / 2
            };

          case "left":
            return {
                top: t === "edge" ? r.top - o : r.center - n.offsetHeight / 2,
                left: r.left - n.offsetWidth
            };

          case "right":
            return {
                top: t === "edge" ? r.top - o : r.center - n.offsetHeight / 2,
                left: r.right
            };

          default:
            throw new Error("".concat(a, " is not a valid placement value. Valid options are: 'above', 'below', 'left', or 'right'"));
        }
    }
    function z(e) {
        var t = e.align, r = e.anchorPos, n = e.scrollContainerPos, o = e.canCoverAnchor, a = e.defaultPlacement, i = e.outerContainerEl, l = e.padding, c = e.repositionMode, f = e.windowHeight, s = e.windowWidth;
        var u = c === "flip";
        var p = c === "any";
        var h = u || p;
        var d = e.placement || a;
 // Translate vertical/horizontal to above/below/left/right
                if (a === "vertical") {
            d = r.top > f - r.bottom ? "above" : "below";
        } else if (a === "horizontal") {
            d = r.left > s - r.right ? "left" : "right";
        }
        var v = d;
 // Initialize the result variables. These will be mutated as needed and returned.
                var m = N({
            align: t,
            anchorPos: r,
            outerContainerEl: i,
            padding: l,
            placement: v
        }), b = m.top, y = m.left;
        var g = "auto";
        var w = s;
        var S = f;
        var O = v;
 // Boolean convenience variables to simplify positioning logic.
                var P = r.top - i.offsetHeight > 0;
        var E = r.bottom + i.offsetHeight < f;
        var C = r.left - i.offsetWidth > 0;
        var j = r.right + i.offsetWidth < s;
        var k = r.top * .7 > f - r.bottom;
        var x = (t === "edge" ? r.left + i.offsetWidth - l : r.middle + i.offsetWidth / 2) > s;
        var A = (t === "edge" ? r.left - l : r.middle - i.offsetWidth / 2) < 0;
        var T = (t === "edge" ? r.top - l : r.top - i.offsetHeight / 2) < 0;
        var R = (t === "edge" ? r.top + i.offsetHeight - l : r.bottom + i.offsetHeight / 2) > f;
 // Handle each of the four placement options individually.
                if (O === "above") {
            if (!P && h) {
                if (E) {
                    return z(I(I({}, e), {}, {
                        placement: "below"
                    }));
                }
                if (p && j) {
                    return z(I(I({}, e), {}, {
                        placement: "right"
                    }));
                }
                if (p && C) {
                    return z(I(I({}, e), {}, {
                        placement: "left"
                    }));
                }
                if (o) {
                    O = "misaligned";
                    b = 0;
                }
            }
            if (O !== "misaligned") {
                g = f - b - i.offsetHeight;
                if (n) {
                    g = Math.min(g, f - n.top);
                }
                b = "auto";
            }
            if (x) {
                y = Math.max(s - i.offsetWidth, 0);
            } else if (A) {
                y = 0;
            }
            if (!o) {
                S = r.top;
            }
        }
        if (O === "below") {
            if (!E && h) {
                if (P && k) {
                    return z(I(I({}, e), {}, {
                        placement: "above"
                    }));
                }
                if (p && j) {
                    return z(I(I({}, e), {}, {
                        placement: "right"
                    }));
                }
                if (p && C) {
                    return z(I(I({}, e), {}, {
                        placement: "left"
                    }));
                }
                if (o) {
                    O = "misaligned";
                    b = 0;
                }
            }
            if (n) {
                b = Math.min(b, n.bottom);
            }
            if (x) {
                y = Math.max(s - i.offsetWidth, 0);
            } else if (A) {
                y = 0;
            }
            if (!o) {
                S = f - r.bottom;
            }
        }
        if (O === "left") {
            if (!C && h) {
                if (j) {
                    return z(I(I({}, e), {}, {
                        placement: "right"
                    }));
                }
                if (p && E) {
                    return z(I(I({}, e), {}, {
                        placement: "below"
                    }));
                }
                if (p && P) {
                    return z(I(I({}, e), {}, {
                        placement: "above"
                    }));
                }
                if (o) {
                    O = "misaligned";
                    b = 0;
                }
            }
            if (T) {
                b = 0;
            } else if (R) {
                b = Math.max(f - i.offsetHeight, 0);
            }
            if (!o) {
                w = r.left;
            }
        }
        if (O === "right") {
            if (!j && h) {
                if (C) {
                    return z(I(I({}, e), {}, {
                        placement: "left"
                    }));
                }
                if (p && E) {
                    return z(I(I({}, e), {}, {
                        placement: "below"
                    }));
                }
                if (p && P) {
                    return z(I(I({}, e), {}, {
                        placement: "above"
                    }));
                }
                if (o) {
                    O = "misaligned";
                    b = 0;
                }
            }
            if (T) {
                b = 0;
            } else if (R) {
                b = Math.max(f - i.offsetHeight, 0);
            }
            if (!o) {
                w = s - r.left;
            }
        }
        return {
            placement: O,
            maxHeight: S,
            maxWidth: w,
            outerContainerStyle: {
                top: b,
                left: y,
                bottom: g
            }
        };
    }
    // CONCATENATED MODULE: ./src/Popover/PopoverContext.tsx
    var $ =  (0, r.createContext)({});
    // CONCATENATED MODULE: external "react-spring"
    const U = require("react-spring");
    // CONCATENATED MODULE: external "styled-components"
    const K = require("styled-components");
    var V =  e.n(K);
    // CONCATENATED MODULE: ./src/Popover/PopoverStyles.ts
    var B = (0, A.pick)({
        enterprise: "8px",
        prisma: 0
    });
    var X = V()(U.animated.div).withConfig({
        displayName: "PopoverStyles__Styled",
        componentId: "sc-1nahsvw-0"
    })([ "position:fixed;z-index:", ";left:-300%;top:-300%;" ], A.variables.zindexPopover);
    var Y = V().div.withConfig({
        displayName: "PopoverStyles__StyledBox",
        componentId: "sc-1nahsvw-1"
    })([ "", ";", ";", ";" ], A.mixins.reset("block"), (function(e) {
        var t = e.$open;
        return !t && (0, K.css)([ "pointer-events:none;" ]);
    }), (function(e) {
        var t = e.$appearance;
        return t !== "none" && (0, K.css)([ "padding:8px;" ]);
    }));
    var G = V().div.withConfig({
        displayName: "PopoverStyles__StyledContent",
        componentId: "sc-1nahsvw-2"
    })([ "", "" ], (0, A.pickVariant)("$appearance", {
        normal: (0, K.css)([ "background-color:", ";color:", ";border:", ";box-shadow:", ";border-radius:", ";" ], A.variables.backgroundColorPopup, A.variables.contentColorDefault, (0, 
        A.pick)({
            enterprise: {
                light: A.variables.border,
                dark: A.variables.border
            },
            prisma: "none"
        }), (0, A.pick)({
            enterprise: {
                light: (0, K.css)([ "0 2px 2px ", "" ], A.mixins.colorWithAlpha(A.variables.gray20, .1)),
                dark: "0 1px 2px #000"
            },
            prisma: A.variables.overlayShadow
        }), A.variables.borderRadius),
        // Enterprise Only
        inverted: (0, K.css)([ "background-color:", ";color:", ";" ], (0, A.pick)({
            light: A.variables.gray20,
            dark: A.variables.white
        }), (0, A.pick)({
            light: A.variables.white,
            dark: A.variables.gray30
        }))
    }));
 // Enterprise Only
        var J = V().div.withConfig({
        displayName: "PopoverStyles__StyledArrow",
        componentId: "sc-1nahsvw-3"
    })([ "width:0;height:0;border-left:", " solid transparent;border-right:", " solid transparent;position:absolute;border-bottom-width:", ";border-bottom-style:solid;", "" ], B, B, B, (0, 
    A.pickVariant)("$appearance", {
        normal: (0, K.css)([ "border-bottom-color:", ";&::before{content:'';display:block;width:0;height:0;border-left:", " solid transparent;border-right:", " solid transparent;border-bottom:", " solid ", ";position:absolute;top:1px;left:0;margin-left:-", ";}" ], (0, 
        A.pick)({
            light: A.variables.borderColor,
            dark: A.variables.black
        }), B, B, B, A.variables.backgroundColor, B),
        inverted: (0, K.css)([ "border-bottom-color:", ";" ], (0, A.pick)({
            light: A.variables.gray20,
            dark: A.variables.white
        }))
    }));
    var Q = V().div.withConfig({
        displayName: "PopoverStyles__StyledLowerRightCorner",
        componentId: "sc-1nahsvw-4"
    })([ "position:fixed;right:0;bottom:0;" ]);
    var Z = V().svg.withConfig({
        displayName: "PopoverStyles__StyledHitArea",
        componentId: "sc-1nahsvw-5"
    })([ "position:fixed;pointer-events:none;path{pointer-events:auto;stroke-width:0;stroke:transparent;fill:transparent;}" ]);
    // CONCATENATED MODULE: ./src/Popover/PopoverHitArea.tsx
    function ee(e, t) {
        return ae(e) || oe(e, t) || re(e, t) || te();
    }
    function te() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function re(e, t) {
        if (!e) return;
        if (typeof e === "string") return ne(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        if (r === "Object" && e.constructor) r = e.constructor.name;
        if (r === "Map" || r === "Set") return Array.from(e);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return ne(e, t);
    }
    function ne(e, t) {
        if (t == null || t > e.length) t = e.length;
        for (var r = 0, n = new Array(t); r < t; r++) {
            n[r] = e[r];
        }
        return n;
    }
    function oe(e, t) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(e))) return;
        var r = [];
        var n = true;
        var o = false;
        var a = undefined;
        try {
            for (var i = e[Symbol.iterator](), l; !(n = (l = i.next()).done); n = true) {
                r.push(l.value);
                if (t && r.length === t) break;
            }
        } catch (e) {
            o = true;
            a = e;
        } finally {
            try {
                if (!n && i["return"] != null) i["return"]();
            } finally {
                if (o) throw a;
            }
        }
        return r;
    }
    function ae(e) {
        if (Array.isArray(e)) return e;
    }
    var ie = {
        anchorRect: a().object,
        popoverEl: a().object,
        popoverPlacement: a().oneOf([ "above", "below", "left", "right", "misaligned" ])
    };
    var le = function e(t) {
        var r = t.anchorRect, n = t.popoverEl, o = t.popoverPlacement;
        if (r != null && n != null && o != null) {
            var a = n.getBoundingClientRect();
            if (o === "above" || o === "below") {
                var i = r.left - a.left;
                var l = r.height;
                var c = 0;
                if (o === "above") {
                    l = 0;
                    c = r.height;
                }
                var f = "0 ".concat(l);
                var s = "".concat(a.width, " ").concat(l);
                var u = "".concat(i, " ").concat(l);
                var p = "".concat(i, " ").concat(c);
                var h = "".concat(i + r.width, " ").concat(l);
                var d = "".concat(i + r.width, " ").concat(c);
                var v = "\n                        M ".concat(f, "\n                        S ").concat(u, " , ").concat(p, "\n                        L ").concat(u, "\n                        L ").concat(h, "\n                        L ").concat(d, "\n                        S ").concat(h, " , ").concat(s, "\n                    ");
                return {
                    hitAreaPath: v,
                    hitAreaStyle: {
                        left: a.left,
                        top: r.top,
                        width: a.width,
                        height: r.height
                    }
                };
            }
            if (o === "left" || o === "right") {
                var m = r.top - a.top;
                var b = 0;
                var y = r.width;
                if (o === "right") {
                    b = r.width;
                    y = 0;
                }
                var g = "".concat(b, " 0");
                var w = "".concat(b, " ").concat(a.height);
                var S = "".concat(b, " ").concat(m);
                var O = "".concat(y, " ").concat(m);
                var P = "".concat(b, " ").concat(m + r.height);
                var E = "".concat(y, " ").concat(m + r.height);
                var C = "\n                        M ".concat(g, "\n                        S ").concat(S, " , ").concat(O, "\n                        L ").concat(S, "\n                        L ").concat(P, "\n                        L ").concat(E, "\n                        S ").concat(P, " , ").concat(w, "\n                    ");
                return {
                    hitAreaPath: C,
                    hitAreaStyle: {
                        left: r.left,
                        top: a.top,
                        width: r.width,
                        height: a.height
                    }
                };
            }
        }
        return {
            hitAreaPath: null,
            hitAreaStyle: {}
        };
    };
    var ce =  n().forwardRef((function(e, t) {
        var o = e.anchorRect, a = e.popoverEl, i = e.popoverPlacement;
        var l = (0, r.useState)(null), c = ee(l, 2), f = c[0], s = c[1];
        var u = (0, r.useState)({}), p = ee(u, 2), h = p[0], d = p[1];
        (0, r.useEffect)((function() {
            var e = le({
                anchorRect: o,
                popoverEl: a,
                popoverPlacement: i
            }), t = e.hitAreaPath, r = e.hitAreaStyle;
            s(t);
            d(r);
        }), [ o, a, i ]);
        if (f != null) {
            
            return n().createElement(Z, {
                "data-test": "popover-hit-area",
                style: h
            },  n().createElement("path", {
                d: f,
                ref: t
            }));
        }
        return null;
    }));
    ce.propTypes = ie;
    /* harmony default export */    const fe = ce;
    // CONCATENATED MODULE: ./src/utils/ssrDocument.ts
    /* eslint-disable @typescript-eslint/no-empty-function */
    var se = {
        body: {
            appendChild: function e() {
                return [];
            }
        },
        addEventListener: function e() {},
        removeEventListener: function e() {},
        activeElement: {
            blur: function e() {},
            nodeName: ""
        },
        querySelector: function e() {
            return null;
        },
        querySelectorAll: function e() {
            return [];
        },
        getElementById: function e() {
            return null;
        },
        createEvent: function e() {
            return {
                initEvent: function e() {}
            };
        },
        createElement: function e() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute: function e() {},
                getElementsByTagName: function e() {
                    return [];
                }
            };
        },
        createElementNS: function e() {
            return {};
        },
        importNode: function e() {
            return null;
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };
    function ue() {
        var e = typeof document !== "undefined" ? document : se;
        return e;
    }
    // CONCATENATED MODULE: ./src/utils/ssrWindow.ts
    /* eslint-disable @typescript-eslint/no-empty-function */
    var pe = {
        document: se,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState: function e() {},
            pushState: function e() {},
            go: function e() {},
            back: function e() {}
        },
        CustomEvent: function e() {
            return this;
        },
        addEventListener: function e() {},
        removeEventListener: function e() {},
        getComputedStyle: function e() {
            return {
                getPropertyValue: function e() {
                    return "";
                }
            };
        },
        Image: function e() {},
        Date: function e() {},
        screen: {},
        setTimeout: function e() {},
        clearTimeout: function e() {},
        matchMedia: function e() {
            return {};
        },
        requestAnimationFrame: function e(t) {
            if (typeof setTimeout === "undefined") {
                t();
                return null;
            }
            return setTimeout(t, 0);
        },
        cancelAnimationFrame: function e(t) {
            if (typeof setTimeout === "undefined") {
                return;
            }
            clearTimeout(t);
        }
    };
    function he() {
        var e = typeof window !== "undefined" ? window : pe;
        return e;
    }
    // CONCATENATED MODULE: ./src/utils/getBoundingClientRect.ts
    function de(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            if (t) n = n.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            }));
            r.push.apply(r, n);
        }
        return r;
    }
    function ve(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = arguments[t] != null ? arguments[t] : {};
            if (t % 2) {
                de(Object(r), true).forEach((function(t) {
                    me(e, t, r[t]);
                }));
            } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(e, Object.getOwnPropertyDescriptors(r));
            } else {
                de(Object(r)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
                }));
            }
        }
        return e;
    }
    function me(e, t, r) {
        if (t in e) {
            Object.defineProperty(e, t, {
                value: r,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            e[t] = r;
        }
        return e;
    }
    // Checks if browser is Safari
        function be() {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }
 // Formats return value to DOMRect
        function ye(e) {
        return ve(ve({}, e), {}, {
            top: e.y,
            left: e.x,
            right: e.x + e.width,
            bottom: e.y + e.height
        });
    }
    /**
 * Provides DOMRect information about the size of an element and its position relative to the viewport.
 * Accounts for Safari's use of visual viewport and adds offsets to set as layout viewport.
 * @param {Element} element - The element to be evaluated
 * @param {boolean} offsets - Use when position of element relative to the layout viewport offsets are needed for Safari.
 * @returns {Omit<DOMRect, 'toJSON'>}
 * @public
 */    function ge(e, t) {
        var r, n;
        var o = e.getBoundingClientRect();
        var a = be();
        if (!t || !a) {
            return o;
        }
        var i = he();
        var l = o.left + (((r = i.visualViewport) === null || r === void 0 ? void 0 : r.offsetLeft) || 0);
        var c = o.top + (((n = i.visualViewport) === null || n === void 0 ? void 0 : n.offsetTop) || 0);
        var f = o.width, s = o.height;
        return ye({
            width: f,
            height: s,
            x: l,
            y: c
        });
    }
    // CONCATENATED MODULE: ./src/utils/updateReactRef.ts
    /**
 * Updates a React ref. Callback refs and object refs (from `createRef` and `useRef`) are supported.
 *
 * @param ref - The React callback or object ref. Can be `null` or `undefined`.
 * @param current - The new value of the ref.
 */
    function we(e, t) {
        if (e) {
            if (typeof e === "function") {
                e(t);
            } else {
                // the public signature of this util uses React.Ref<T> to mirror the way React types refs.
                // the intention here is to signal "we will take care of setting 'current', not you".
                e.current = t;
 // eslint-disable-line no-param-reassign
                        }
        }
    }
    // CONCATENATED MODULE: ./src/Popover/Popover.tsx
    function Se(e) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            Se = function e(t) {
                return typeof t;
            };
        } else {
            Se = function e(t) {
                return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            };
        }
        return Se(e);
    }
    function Oe() {
        Oe = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var r = arguments[t];
                for (var n in r) {
                    if (Object.prototype.hasOwnProperty.call(r, n)) {
                        e[n] = r[n];
                    }
                }
            }
            return e;
        };
        return Oe.apply(this, arguments);
    }
    function Pe(e) {
        return je(e) || Ce(e) || Re(e) || Ee();
    }
    function Ee() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function Ce(e) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(e)) return Array.from(e);
    }
    function je(e) {
        if (Array.isArray(e)) return qe(e);
    }
    function ke(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            if (t) n = n.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            }));
            r.push.apply(r, n);
        }
        return r;
    }
    function xe(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = arguments[t] != null ? arguments[t] : {};
            if (t % 2) {
                ke(Object(r), true).forEach((function(t) {
                    Ke(e, t, r[t]);
                }));
            } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(e, Object.getOwnPropertyDescriptors(r));
            } else {
                ke(Object(r)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
                }));
            }
        }
        return e;
    }
    function Ae(e, t) {
        return Me(e) || We(e, t) || Re(e, t) || Te();
    }
    function Te() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function Re(e, t) {
        if (!e) return;
        if (typeof e === "string") return qe(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        if (r === "Object" && e.constructor) r = e.constructor.name;
        if (r === "Map" || r === "Set") return Array.from(e);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return qe(e, t);
    }
    function qe(e, t) {
        if (t == null || t > e.length) t = e.length;
        for (var r = 0, n = new Array(t); r < t; r++) {
            n[r] = e[r];
        }
        return n;
    }
    function We(e, t) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(e))) return;
        var r = [];
        var n = true;
        var o = false;
        var a = undefined;
        try {
            for (var i = e[Symbol.iterator](), l; !(n = (l = i.next()).done); n = true) {
                r.push(l.value);
                if (t && r.length === t) break;
            }
        } catch (e) {
            o = true;
            a = e;
        } finally {
            try {
                if (!n && i["return"] != null) i["return"]();
            } finally {
                if (o) throw a;
            }
        }
        return r;
    }
    function Me(e) {
        if (Array.isArray(e)) return e;
    }
    function He(e, t) {
        if (!(e instanceof t)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _e(e, t) {
        for (var r = 0; r < t.length; r++) {
            var n = t[r];
            n.enumerable = n.enumerable || false;
            n.configurable = true;
            if ("value" in n) n.writable = true;
            Object.defineProperty(e, n.key, n);
        }
    }
    function Le(e, t, r) {
        if (t) _e(e.prototype, t);
        if (r) _e(e, r);
        return e;
    }
    function De(e, t) {
        if (typeof t !== "function" && t !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: true,
                configurable: true
            }
        });
        if (t) Ie(e, t);
    }
    function Ie(e, t) {
        Ie = Object.setPrototypeOf || function e(t, r) {
            t.__proto__ = r;
            return t;
        };
        return Ie(e, t);
    }
    function Fe(e) {
        var t = $e();
        return function r() {
            var n = Ue(e), o;
            if (t) {
                var a = Ue(this).constructor;
                o = Reflect.construct(n, arguments, a);
            } else {
                o = n.apply(this, arguments);
            }
            return Ne(this, o);
        };
    }
    function Ne(e, t) {
        if (t && (Se(t) === "object" || typeof t === "function")) {
            return t;
        }
        return ze(e);
    }
    function ze(e) {
        if (e === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return e;
    }
    function $e() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
            Date.prototype.toString.call(Reflect.construct(Date, [], (function() {})));
            return true;
        } catch (e) {
            return false;
        }
    }
    function Ue(e) {
        Ue = Object.setPrototypeOf ? Object.getPrototypeOf : function e(t) {
            return t.__proto__ || Object.getPrototypeOf(t);
        };
        return Ue(e);
    }
    function Ke(e, t, r) {
        if (t in e) {
            Object.defineProperty(e, t, {
                value: r,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            e[t] = r;
        }
        return e;
    }
    /** @public */    var Ve = [ "clickAway", "escapeKey", "offScreen", "tabKey" ];
    var Be = {
        align: a().oneOf([ "center", "edge", "theme", "end" ]),
        anchor: a().object,
        animation: a().bool,
        animationConfig: a().object,
        appearance: a().oneOf([ "normal", "inverted", "none" ]),
        autoCloseWhenOffScreen: a().bool,
        canCoverAnchor: a().bool,
        children: a().oneOfType([ a().node, a().func ]),
        closeReasons: a().arrayOf(a().oneOf(Ve)),
        defaultPlacement: a().oneOf([ "above", "below", "left", "right", "vertical", "horizontal" ]),
        elementRef: a().oneOfType([ a().func, a().object ]),
        id: a().string,
        hitAreaRef: a().oneOfType([ a().func, a().object ]),
        onRequestClose: a().func,
        open: a().bool,
        outerRef: a().oneOfType([ a().func, a().object ]),
        pointTo: a().shape({
            x: a().number,
            y: a().number
        }),
        repositionMode: a().oneOf([ "none", "flip", "any" ]),
        retainFocus: a().bool,
        takeFocus: a().bool,
        splunkTheme: a().object
    };
    var Xe = {
        align: "theme",
        animation: true,
        animationConfig: {},
        appearance: "normal",
        autoCloseWhenOffScreen: true,
        canCoverAnchor: false,
        closeReasons: Ve,
        defaultPlacement: "below",
        open: false,
        repositionMode: "flip",
        retainFocus: true,
        takeFocus: false
    };
    // eslint-disable-next-line @typescript-eslint/ban-types
        function Ye(e, t) {
        var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        return !!e && !!t && p()(e, (function(e, n) {
            if (w()(e)) {
                return Math.abs(t[n] - e) <= r;
            }
            return t[n] === e;
        }));
    }
    function Ge(e) {
        return e !== window && e !== window.document;
    }
    /**
 * `Popover` is used to create layovers such as dropdowns, contextual menus, or tooltips. Use
 * this only when the other components don't provide sufficient functionality or control. A controlled
 * `Dropdown` covers use cases where you might consider using `Popover` directly.
 */    var Je =  function(e) {
        De(r, e);
        var t = Fe(r);
        Le(r, null, [ {
            key: "getArrowStyle",
            // @docs-props-type PopoverPropsBase
            value: function e(t) {
                var r = t.anchorPos, n = t.arrowHeight, o = t.placement, a = t.outerContainerStyle, i = t.outerContainerEl;
                if (o === "misaligned") {
                    return [ {
                        display: "none"
                    } ];
                }
                var l = {
                    display: "block"
                };
                var f = i.offsetHeight / 2 - 22;
                var s = -(i.offsetHeight / 2 - 15);
                var u = r.center - (a.top + i.offsetHeight / 2) - n / 2;
                var p = c()(u, s, f);
                var h = r.middle - (a.left + i.offsetWidth / 2) - n;
                var d = {
                    left: {
                        translateX: n / 2,
                        translateY: p,
                        rotate: 90
                    },
                    right: {
                        translateX: -n / 2,
                        translateY: p,
                        rotate: -90
                    },
                    above: {
                        translateX: h,
                        translateY: 0,
                        rotate: 180
                    },
                    below: {
                        translateX: h,
                        translateY: 0,
                        rotate: 0
                    }
                };
                var v = d[o];
                l.transform = "translate(".concat(v.translateX, "px, ").concat(v.translateY, "px) rotate(").concat(v.rotate, "deg)");
 // set new positions
                                var m = {
                    left: "right",
                    right: "left",
                    above: "bottom",
                    below: "top"
                };
                l[m[o]] = "1px";
                var b = {
                    left: "top",
                    right: "top",
                    above: "left",
                    below: "left"
                };
                l[b[o]] = "50%";
                return [ l, v ];
            }
        } ]);
        function r(e) {
            var o;
            He(this, r);
            o = t.call(this, e);
            Ke(ze(o), "outerContainerEl", null);
            Ke(ze(o), "innerContainerEl", null);
            Ke(ze(o), "arrow", null);
            Ke(ze(o), "windowSizeMeasurementEl", null);
            Ke(ze(o), "handleScroll", void 0);
            Ke(ze(o), "handleWindowScroll", void 0);
            Ke(ze(o), "allowAnimationUpdates", true);
            Ke(ze(o), "getElPosition", (function(e) {
                var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var r = ge(e, t);
                var n = {
                    width: e.offsetWidth,
                    height: e.offsetHeight
                };
                var a = o.props.pointTo;
                var i = a && d()(a, "x");
                var l = a && d()(a, "y");
                n.left = i ? r.left + ((a === null || a === void 0 ? void 0 : a.x) || 0) : r.left;
                n.top = l ? r.top + ((a === null || a === void 0 ? void 0 : a.y) || 0) : r.top;
                n.right = i ? n.left + n.width : r.left + n.width || r.right;
                n.bottom = l ? n.top + n.height : r.top + n.height || r.bottom;
                n.middle = i ? n.left : r.left + (n.right - r.left) / 2;
                n.center = l ? n.top : r.top + (n.bottom - r.top) / 2;
                return n;
            }));
            Ke(ze(o), "setPlacement", (function(e) {
                var t = he();
                o.setState((function(n) {
                    var a;
                    var i = o.props, l = i.align, c = i.anchor, f = i.autoCloseWhenOffScreen, s = i.canCoverAnchor, u = i.defaultPlacement, p = i.open, h = i.repositionMode, d = i.splunkTheme;
                    var v = o.context || t;
                    var m = d.isPrisma;
 // If these conditions are not met, we cannot set the popover.
                                        if (!p || !o.outerContainerEl || !c || !n.anchorEl || !o.windowSizeMeasurementEl) {
                        if (false) {}
                        return null;
                    }
                    var b = o.getElPosition(n.anchorEl);
                    var y = o.getElPosition(n.anchorEl, true);
                    var g = Ge(v) ? o.getElPosition(v) : undefined;
                    if (e && f) {
                        if (o.autoCloseWhenOffScreen(b, g)) {
                            return null;
                        }
                    }
                    var w = m ? 0 : 8;
                    var S = 8;
                    var O = m ? "edge" : "center";
                    var P = z({
                        align: l === "theme" ? O : l,
                        anchorPos: y,
                        scrollContainerPos: g,
                        canCoverAnchor: s,
                        defaultPlacement: u,
                        repositionMode: h,
                        outerContainerEl: o.outerContainerEl,
                        padding: S,
                        windowWidth: o.windowSizeMeasurementEl.offsetLeft,
                        windowHeight: o.windowSizeMeasurementEl.offsetTop
                    }), E = P.placement, C = P.outerContainerStyle, k = P.maxHeight, x = P.maxWidth;
                    var A = o.arrow ? r.getArrowStyle({
                        anchorPos: y,
                        arrowHeight: w,
                        outerContainerStyle: C,
                        placement: E,
                        outerContainerEl: o.outerContainerEl
                    }) : [], T = Ae(A, 2), R = T[0], q = T[1];
                    var W = o.props.appearance !== "none" && !m;
                    var M = Ye(y, n.anchorPos) && Ye(C, n.outerContainerStyle) && E === n.placement && k === n.maxHeight && x === n.maxWidth;
                    var H = Ye(j()(R, "transform"), j()(n.arrowStyle, "transform")) && Ye(q !== null && q !== void 0 ? q : {}, (a = n.arrowStyleTransformMeta) !== null && a !== void 0 ? a : {});
 // If none of the position data has changed, do not set state.
                                        if (M && (!W || W && H)) {
                        return null;
                    }
                    return {
                        anchorPos: y,
                        arrowStyle: R,
                        arrowStyleTransformMeta: q,
                        outerContainerStyle: C,
                        placement: E,
                        maxHeight: k,
                        maxWidth: x
                    };
                }));
            }));
            Ke(ze(o), "handleNewAnchor", (function(e) {
                var t;
                if (e && !(e instanceof HTMLElement)) {
                    if (false) {}
                    t = (0, i.findDOMNode)(e);
 // eslint-disable-line react/no-find-dom-node
                                } else {
                    t = e !== null && e !== void 0 ? e : undefined;
                }
                var r = t ? o.getElPosition(t) : undefined;
                o.setState({
                    anchorEl: t,
                    anchorPos: r
                });
 // eslint-disable-line react/no-unused-state
                        }));
            Ke(ze(o), "handleInnerContainerMount", (function(e) {
                o.innerContainerEl = e;
                if (e && o.props.takeFocus) {
                    s()(L.takeFocus, e);
                }
                we(o.props.elementRef, e);
            }));
            Ke(ze(o), "handleOuterContainerMount", (function(e) {
                o.outerContainerEl = e;
                we(o.props.outerRef, e);
            }));
            Ke(ze(o), "handleTab", (function(e) {
                if (o.innerContainerEl) {
                    if (o.props.retainFocus) {
                        (0, L.handleTab)(o.innerContainerEl, e);
                    } else if ((0, L.isTabKey)(e)) {
                        var t = (0, L.getSortedTabbableElements)(o.innerContainerEl);
                        if (t.length > 0) {
                            var r = e.shiftKey ? t[0] : t[t.length - 1];
                            if (r === e.target) {
                                o.handleRequestClose({
                                    event: e,
                                    reason: "tabKey"
                                });
                            }
                        }
                    }
                }
            }));
            Ke(ze(o), "handleRequestClose", (function(e) {
                if (o.props.open) {
                    o.requestClose(e);
                }
            }));
            Ke(ze(o), "handleAnimationEnd", (function() {
                if (o.allowAnimationUpdates) {
                    o.setState({
                        animating: false
                    });
                }
            }));
            Ke(ze(o), "renderLayer", (function() {
                var e = o.props, t = e.animation, a = e.animationConfig, i = e.appearance, l = e.children, c = e.id, f = e.open, s = e.retainFocus, u = e.splunkTheme;
                var p = o.state, h = p.anchorPos, d = p.arrowStyle, v = p.outerContainerStyle, m = p.placement;
                var b = u.isPrisma;
                var y = b && i === "inverted" ? "normal" : i;
                var g = o.state, S = g.maxHeight, P = g.maxWidth;
 // eslint-disable-line prefer-const
                // Accommodate the arrow in the maxHeight and maxWidth.
                                if (i !== "none") {
                    if (w()(S)) {
                        S -= 20;
                    }
                    if (w()(P)) {
                        P -= 20;
                    }
                }
                var C = {
                    anchorHeight: h ? h.height : null,
                    anchorWidth: h ? h.width : null,
                    placement: m || null,
                    maxHeight: S || null,
                    maxWidth: P || null
                };
                var k = t ? {
                    opacity: f ? 1 : 0
                } : {
                    opacity: 1
                };
                /* eslint-disable jsx-a11y/no-static-element-interactions */                
                return n().createElement(T.Spring, {
                    from: {
                        opacity: t ? 0 : 1
                    },
                    to: k,
                    config: xe({
                        tension: 300,
                        friction: 40
                    }, a),
                    onRest: o.handleAnimationEnd
                }, (function(e) {
                    
                    return n().createElement(X, {
                        "data-test": "outer-popover",
                        style: xe(xe({}, v), e),
                        ref: o.handleOuterContainerMount
                    }, (f || o.state.animating) &&  n().createElement(Y, Oe({
                        $appearance: y,
                        $open: f,
                        "data-test": "popover",
                        ref: o.handleInnerContainerMount,
                        tabIndex: -1,
                        id: c,
                        onKeyDown: o.handleTab
                    }, j()(o.props, [ "anchor" ].concat(Pe(E()(r.propTypes))))),  n().createElement($.Provider, {
                        value: {
                            retainFocus: s
                        }
                    },  n().createElement(n().Fragment, null, i === "none" && l, i !== "none" && !b &&  n().createElement(J, {
                        $appearance: y,
                        ref: function e(t) {
                            o.arrow = t;
                        },
                        style: d
                    }), i !== "none" &&  n().createElement(G, {
                        $appearance: y
                    }, O()(l) ? l(C) : l)))),  n().createElement(Q, {
                        ref: function e(t) {
                            o.windowSizeMeasurementEl = t;
                        }
                    }));
                }));
                /* eslint-enable jsx-a11y/no-static-element-interactions */            }));
            o.handleScroll = x()(o.setPlacement.bind(ze(o), true), 0);
            o.handleWindowScroll = x()(o.setPlacement.bind(ze(o), true), 0);
            o.setPlacement = x()(o.setPlacement, 0, {
                leading: false
            });
            o.state = {
                animating: false,
                prevOpen: e.open
            };
            return o;
        }
        Le(r, [ {
            key: "componentDidMount",
            value: function e() {
                this.handleNewAnchor(this.props.anchor);
            }
        }, {
            key: "componentDidUpdate",
            value: function e(t) {
                if (t.anchor !== this.props.anchor) {
                    this.handleNewAnchor(this.props.anchor);
                }
                if (!this.innerContainerEl) {
                    return;
                }
                if (this.props.open || this.state.animating) {
                    this.setPlacement();
 // make sure that the popover both was not open before and is actually open now
                    // this prevents bugs like #4 in SUI-2054 where popover contents re-rendering due to animation
                    // causes the popover contents to receive focus even though the popover closing
                                        if (!t.open && this.props.open && this.props.takeFocus) {
                        (0, L.takeFocus)(this.innerContainerEl);
                    }
                }
            }
        }, {
            key: "componentWillUnmount",
            value: function e() {
                this.setPlacement.cancel();
 // guaranteed by constructor
                                this.handleScroll.cancel();
                this.allowAnimationUpdates = false;
            }
        }, {
            key: "autoCloseWhenOffScreen",
            value: function e(t, r) {
                var n = he();
                if (t.top < 0 || t.top > n.innerHeight || t.left < 0 || t.left > n.innerWidth) {
                    this.requestClose({
                        reason: "offScreen"
                    });
                    return true;
                }
                if (r) {
                    if (t.height + t.top < r.top || t.top > r.bottom || t.width + t.left < r.left || t.left > r.right) {
                        this.requestClose({
                            reason: "offScreen"
                        });
                        return true;
                    }
                }
                return false;
            }
        }, {
            key: "requestClose",
            value: function e(t) {
                if (m()(this.props.closeReasons, t.reason)) {
                    var r, n;
                    (r = (n = this.props).onRequestClose) === null || r === void 0 ? void 0 : r.call(n, t);
                }
            }
        }, {
            key: "render",
            value: function e() {
                var t = he();
                var r = this.props.open || this.state.animating;
                var o = this.context || t;
                var a = o !== t;
                var i = this.state, l = i.anchorPos, c = i.placement;
 // EventListeners only need to be rendered when open,
                // otherwise leads to negative performance impacts
                                var f = r ? [ a &&  n().createElement(q(), {
                    target: o,
                    eventType: "scroll",
                    listener: this.handleScroll,
                    options: {
                        passive: false,
                        capture: true
                    },
                    key: "eventListener"
                }),  n().createElement(q(), {
                    target: t,
                    eventType: "resize",
                    listener: this.setPlacement,
                    key: "eventListenerOnWindowResize"
                }),  n().createElement(q(), {
                    target: t,
                    eventType: "scroll",
                    listener: this.handleWindowScroll,
                    options: {
                        passive: false,
                        capture: true
                    },
                    key: "eventListenerOnWindowScroll"
                }) ] : [];
                return [].concat(f, [  n().createElement(M(), {
                    closeReasons: y()(this.props.closeReasons.filter((function(e) {
                        return e !== "offScreen";
                    })), M().possibleCloseReasons),
                    open: r,
                    onRequestClose: this.handleRequestClose,
                    key: "Layer"
                }, r && this.innerContainerEl && this.props.hitAreaRef &&  n().createElement(fe, {
                    anchorRect: l,
                    popoverEl: this.innerContainerEl,
                    popoverPlacement: c,
                    ref: this.props.hitAreaRef
                }), r && this.renderLayer()) ]);
            }
        } ]);
        return r;
    }(r.Component);
    Ke(Je, "contextType", _());
    Ke(Je, "defaultProps", Xe);
    Ke(Je, "propTypes", Be);
    Ke(Je, "getDerivedStateFromProps", (function(e, t) {
        if (e.open !== t.prevOpen) {
            return {
                animating: e.animation,
                prevOpen: e.open
            };
        }
        return null;
    }));
    var Qe = (0, A.withSplunkTheme)(Je);
    Qe.propTypes = Je.propTypes;
    /* harmony default export */    const Ze = Qe;
    // CONCATENATED MODULE: ./src/Popover/index.ts
    module.exports = t;
    /******/})();