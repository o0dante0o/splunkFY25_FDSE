/******/ (() => {
    // webpackBootstrap
    /******/ "use strict";
    /******/ // The require scope
    /******/    var e = {};
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/    (() => {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ e.n = t => {
            /******/ var o = t && t.__esModule ? 
            /******/ () => t["default"]
            /******/ : () => t
            /******/;
            e.d(o, {
                a: o
            });
            /******/            return o;
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/define property getters */
    /******/    (() => {
        /******/ // define getter functions for harmony exports
        /******/ e.d = (t, o) => {
            /******/ for (var n in o) {
                /******/ if (e.o(o, n) && !e.o(t, n)) {
                    /******/ Object.defineProperty(t, n, {
                        enumerable: true,
                        get: o[n]
                    });
                    /******/                }
                /******/            }
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/    (() => {
        /******/ e.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)
        /******/;
    })();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/    (() => {
        /******/ // define __esModule on exports
        /******/ e.r = e => {
            /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                /******/ Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                });
                /******/            }
            /******/            Object.defineProperty(e, "__esModule", {
                value: true
            });
            /******/        };
        /******/    })();
    /******/
    /************************************************************************/    var t = {};
    // ESM COMPAT FLAG
        e.r(t);
    // EXPORTS
        e.d(t, {
        default: () => /* reexport */ N,
        legacyRefMode: () => /* reexport */ W
    });
    // CONCATENATED MODULE: external "react"
    const o = require("react");
    var n =  e.n(o);
    // CONCATENATED MODULE: external "prop-types"
    const r = require("prop-types");
    var l =  e.n(r);
    // CONCATENATED MODULE: external "lodash/has"
    const i = require("lodash/has");
    var s =  e.n(i);
    // CONCATENATED MODULE: external "lodash/includes"
    const a = require("lodash/includes");
    var c =  e.n(a);
    // CONCATENATED MODULE: external "lodash/isEmpty"
    const u = require("lodash/isEmpty");
    // CONCATENATED MODULE: external "lodash/isFunction"
    const p = require("lodash/isFunction");
    var f =  e.n(p);
    // CONCATENATED MODULE: external "lodash/keys"
    const d = require("lodash/keys");
    var g =  e.n(d);
    // CONCATENATED MODULE: external "lodash/omit"
    const y = require("lodash/omit");
    var v =  e.n(y);
    // CONCATENATED MODULE: external "@splunk/ui-utils/id"
    const h = require("@splunk/ui-utils/id");
    // CONCATENATED MODULE: external "@splunk/ui-utils/keyboard"
    const b = require("@splunk/ui-utils/keyboard");
    // CONCATENATED MODULE: external "@splunk/react-ui/Popover"
    const O = require("@splunk/react-ui/Popover");
    var m =  e.n(O);
    // CONCATENATED MODULE: ./src/utils/updateReactRef.ts
    /**
 * Updates a React ref. Callback refs and object refs (from `createRef` and `useRef`) are supported.
 *
 * @param ref - The React callback or object ref. Can be `null` or `undefined`.
 * @param current - The new value of the ref.
 */
    function C(e, t) {
        if (e) {
            if (typeof e === "function") {
                e(t);
            } else {
                // the public signature of this util uses React.Ref<T> to mirror the way React types refs.
                // the intention here is to signal "we will take care of setting 'current', not you".
                e.current = t;
 // eslint-disable-line no-param-reassign
                        }
        }
    }
    // CONCATENATED MODULE: ./src/Dropdown/Dropdown.tsx
    function k(e) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            k = function e(t) {
                return typeof t;
            };
        } else {
            k = function e(t) {
                return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            };
        }
        return k(e);
    }
    function R(e, t) {
        var o = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            if (t) n = n.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            }));
            o.push.apply(o, n);
        }
        return o;
    }
    function w(e) {
        for (var t = 1; t < arguments.length; t++) {
            var o = arguments[t] != null ? arguments[t] : {};
            if (t % 2) {
                R(Object(o), true).forEach((function(t) {
                    _(e, t, o[t]);
                }));
            } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(e, Object.getOwnPropertyDescriptors(o));
            } else {
                R(Object(o)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(o, t));
                }));
            }
        }
        return e;
    }
    function P(e, t) {
        if (!(e instanceof t)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function j(e, t) {
        for (var o = 0; o < t.length; o++) {
            var n = t[o];
            n.enumerable = n.enumerable || false;
            n.configurable = true;
            if ("value" in n) n.writable = true;
            Object.defineProperty(e, n.key, n);
        }
    }
    function q(e, t, o) {
        if (t) j(e.prototype, t);
        if (o) j(e, o);
        return e;
    }
    function S(e, t) {
        if (typeof t !== "function" && t !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: true,
                configurable: true
            }
        });
        if (t) T(e, t);
    }
    function T(e, t) {
        T = Object.setPrototypeOf || function e(t, o) {
            t.__proto__ = o;
            return t;
        };
        return T(e, t);
    }
    function D(e) {
        var t = K();
        return function o() {
            var n = M(e), r;
            if (t) {
                var l = M(this).constructor;
                r = Reflect.construct(n, arguments, l);
            } else {
                r = n.apply(this, arguments);
            }
            return I(this, r);
        };
    }
    function I(e, t) {
        if (t && (k(t) === "object" || typeof t === "function")) {
            return t;
        }
        return E(e);
    }
    function E(e) {
        if (e === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return e;
    }
    function K() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
            Date.prototype.toString.call(Reflect.construct(Date, [], (function() {})));
            return true;
        } catch (e) {
            return false;
        }
    }
    function M(e) {
        M = Object.setPrototypeOf ? Object.getPrototypeOf : function e(t) {
            return t.__proto__ || Object.getPrototypeOf(t);
        };
        return M(e);
    }
    function _(e, t, o) {
        if (t in e) {
            Object.defineProperty(e, t, {
                value: o,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            e[t] = o;
        }
        return e;
    }
    /** @public */    var F = [ "clickAway", "contentClick", "escapeKey", "offScreen", "tabKey", "toggleClick" ];
    var A = {
        align: l().oneOf([ "center", "edge", "theme", "end" ]),
        canCoverAnchor: l().bool,
        children: l().oneOfType([ l().node, l().func ]),
        closeReasons: l().arrayOf(l().oneOf(F)),
        defaultPlacement: l().oneOf([ "above", "below", "left", "right", "vertical", "horizontal" ]),
        elementRef: l().oneOfType([ l().func, l().object ]),
        focusToggleReasons: l().arrayOf(l().oneOf(F)),
        inputId: l().string,
        onRequestClose: l().func,
        onRequestOpen: l().func,
        open: l().bool,
        openWithArrowKeys: l().bool,
        repositionMode: l().oneOf([ "none", "flip", "any" ]),
        retainFocus: l().bool,
        takeFocus: l().bool,
        toggle: l().element.isRequired
    };
    var x = {
        align: "theme",
        canCoverAnchor: true,
        closeReasons: F,
        defaultPlacement: "below",
        focusToggleReasons: [ "contentClick", "escapeKey", "tabKey", "toggleClick" ],
        repositionMode: "flip",
        retainFocus: false,
        openWithArrowKeys: false,
        takeFocus: true
    };
    var W = Symbol("Dropdown legacy ref mode marker");
    var z =  function(e) {
        S(r, e);
        var t = D(r);
        // @docs-props-type DropdownPropsBase
        /**
   * Enumeration of the possible reasons for closing the Select.
   * 'clickAway', 'escapeKey', and 'offScreen' are inherited from Popover, but repeated here for
   * docs extraction.
   */        function r(e) {
            var o;
            P(this, r);
            o = t.call(this, e);
            _(E(o), "controlledExternally", void 0);
            _(E(o), "popoverId", void 0);
            _(E(o), "toggleRef", null);
            _(E(o), "toggleId", void 0);
            _(E(o), "handleToggleMount", (function(e) {
                o.toggleRef = e;
                o.setState({
                    anchor: e
                });
                if (o.props.toggle.type[W]) {
                    // TS: assume that legacy ref mode toggles support elementRef
                    C(o.props.toggle.props.elementRef, e);
                } else {
                    // TS: ref does not exist on React.ReactElement - technically, this is undocumented API
                    C(o.props.toggle.ref, e);
                }
            }));
            _(E(o), "handleToggleClick", (function(e) {
                var t, n;
                (t = (n = o.props.toggle.props).onClick) === null || t === void 0 ? void 0 : t.call(n, e);
                if (o.isOpen()) {
                    o.handleRequestClose({
                        reason: "toggleClick",
                        event: e
                    });
                } else {
                    var r, l;
                    (r = (l = o.props).onRequestOpen) === null || r === void 0 ? void 0 : r.call(l, e, {
                        reason: "toggleClick"
                    });
                    if (!o.isControlled()) {
                        o.setState({
                            open: true
                        });
                    }
                }
            }));
            _(E(o), "handleToggleKeyDownOpen", (function(e) {
                var t, n;
                (t = (n = o.props.toggle.props).onKeyDown) === null || t === void 0 ? void 0 : t.call(n, e);
                if (!o.props.openWithArrowKeys) {
                    return;
                }
                var r = (0, b.keycode)(e.nativeEvent);
                if (r === "up" || r === "down") {
                    var l, i;
                    e.preventDefault();
                    (l = (i = o.props).onRequestOpen) === null || l === void 0 ? void 0 : l.call(i, e, {
                        reason: "toggleKeydown"
                    });
                    if (!o.isControlled()) {
                        o.setState({
                            open: true
                        });
                    }
                }
            }));
            _(E(o), "handleRequestClose", (function(e) {
                var t = e.event, n = e.reason;
                var r = o.props, l = r.closeReasons, i = r.focusToggleReasons, s = r.onRequestClose;
                if (t && n === "clickAway") {
                    var a = t.target;
                    var u = o.props.inputId || o.props.toggle.props.id || o.toggleId;
                    while (a) {
                        // Ignore clicks on toggle.
                        if (a.id === u) {
                            return;
                        }
                        a = a.parentNode;
                    }
                }
                if (o.isOpen() && c()(l, n)) {
                    if (c()(i, n)) {
                        o.focus();
                    }
                    if (!o.isControlled()) {
                        o.setState({
                            open: false
                        });
                    }
                    s === null || s === void 0 ? void 0 : s(e);
                }
            }));
            _(E(o), "handleContentClick", (function(e) {
                o.handleRequestClose({
                    reason: "contentClick",
                    event: e
                });
            }));
            o.state = {
                anchor: null,
                open: false
            };
            o.controlledExternally = s()(e, "open");
            o.popoverId = (0, h.createDOMID)("popover");
            o.toggleId = (0, h.createDOMID)("toggle");
            return o;
        }
        q(r, [ {
            key: "componentDidUpdate",
            value: function e() {
                if (false) {}
                var t = w({}, v()(this.props, g()(r.propTypes), "value", "id"));
                if (false) {}
            }
        }, {
            key: "isOpen",
            value: function e() {
                return this.isControlled() ? this.props.open : this.state.open;
            }
            /**
     * Places focus on the toggle.
     */        }, {
            key: "focus",
            value: function e() {
                var t;
                (t = this.toggleRef) === null || t === void 0 ? void 0 : t.focus();
            }
        }, {
            key: "isControlled",
            value: function e() {
                return this.controlledExternally;
            }
        }, {
            key: "renderToggle",
            value: function e() {
                var t;
                
                return (0, o.cloneElement)(this.props.toggle, (t = {
                    onClick: this.handleToggleClick,
                    onKeyDown: this.handleToggleKeyDownOpen
                }, _(t, this.props.toggle.type[W] ? "elementRef" : "ref", this.handleToggleMount), 
                _(t, "aria-controls", this.isOpen() ? this.popoverId : undefined), _(t, "aria-haspopup", this.props.toggle.props["aria-haspopup"] || true), 
                _(t, "aria-expanded", this.isOpen()), _(t, "data-test", this.props.toggle.props["data-test"] || "dropdown"), 
                _(t, "data-test-popover-id", this.popoverId), _(t, "id", this.props.inputId || this.props.toggle.props.id || this.toggleId), 
                t));
            }
        }, {
            key: "render",
            value: function e() {
                var t = this.props, o = t.align, r = t.canCoverAnchor, l = t.children, i = t.closeReasons, s = t.defaultPlacement, a = t.elementRef, u = t.repositionMode, p = t.retainFocus, d = t.takeFocus;
                var g = this.state.anchor;
                var y = this.handleRequestClose, v = this.handleContentClick;
                var h = this.renderToggle();
                
                return n().createElement(n().Fragment, null, h,  n().createElement(m(), {
                    align: o,
                    open: !!g && this.isOpen(),
                    autoCloseWhenOffScreen: c()(i, "offScreen"),
                    anchor: g,
                    canCoverAnchor: r,
                    elementRef: a,
                    retainFocus: p,
                    defaultPlacement: s,
                    onRequestClose: y,
                    repositionMode: u,
                    id: this.popoverId,
                    "aria-labelledby": this.props.inputId || this.props.toggle.props.id || this.toggleId,
                    takeFocus: d
                }, f()(l) ? // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
                function() {
                    
                    return n().createElement("div", {
                        onClick: v
                    }, l.apply(void 0, arguments));
                } : 
                
                // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
                n().createElement("div", {
                    onClick: v
                }, l)));
            }
        } ]);
        return r;
    }(o.Component);
    _(z, "possibleCloseReasons", F);
    _(z, "propTypes", A);
    _(z, "defaultProps", x);
    /* harmony default export */    const N = z;
    // CONCATENATED MODULE: ./src/Dropdown/index.ts
    module.exports = t;
    /******/})();