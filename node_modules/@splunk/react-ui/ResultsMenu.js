/******/ (() => {
    // webpackBootstrap
    /******/ "use strict";
    /******/ // The require scope
    /******/    var e = {};
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/compat get default export */
    /******/    (() => {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ e.n = t => {
            /******/ var r = t && t.__esModule ? 
            /******/ () => t["default"]
            /******/ : () => t
            /******/;
            e.d(r, {
                a: r
            });
            /******/            return r;
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/define property getters */
    /******/    (() => {
        /******/ // define getter functions for harmony exports
        /******/ e.d = (t, r) => {
            /******/ for (var n in r) {
                /******/ if (e.o(r, n) && !e.o(t, n)) {
                    /******/ Object.defineProperty(t, n, {
                        enumerable: true,
                        get: r[n]
                    });
                    /******/                }
                /******/            }
            /******/        };
        /******/    })();
    /******/
    /******/ /* webpack/runtime/hasOwnProperty shorthand */
    /******/    (() => {
        /******/ e.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)
        /******/;
    })();
    /******/
    /******/ /* webpack/runtime/make namespace object */
    /******/    (() => {
        /******/ // define __esModule on exports
        /******/ e.r = e => {
            /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                /******/ Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                });
                /******/            }
            /******/            Object.defineProperty(e, "__esModule", {
                value: true
            });
            /******/        };
        /******/    })();
    /******/
    /************************************************************************/    var t = {};
    // ESM COMPAT FLAG
        e.r(t);
    // EXPORTS
        e.d(t, {
        VirtualizedResultsMenu: () => /* reexport */ Le,
        default: () => /* reexport */ $
    });
    // CONCATENATED MODULE: external "react"
    const r = require("react");
    var n =  e.n(r);
    // CONCATENATED MODULE: external "prop-types"
    const o = require("prop-types");
    var i =  e.n(o);
    // CONCATENATED MODULE: external "lodash/keys"
    const u = require("lodash/keys");
    var a =  e.n(u);
    // CONCATENATED MODULE: external "lodash/memoize"
    const l = require("lodash/memoize");
    var c =  e.n(l);
    // CONCATENATED MODULE: external "lodash/omit"
    const s = require("lodash/omit");
    var f =  e.n(s);
    // CONCATENATED MODULE: external "@splunk/ui-utils/i18n"
    const d = require("@splunk/ui-utils/i18n");
    // CONCATENATED MODULE: external "@splunk/ui-utils/userAgent"
    const p = require("@splunk/ui-utils/userAgent");
    // CONCATENATED MODULE: external "@splunk/react-ui/Menu"
    const v = require("@splunk/react-ui/Menu");
    var m =  e.n(v);
    // CONCATENATED MODULE: external "styled-components"
    const y = require("styled-components");
    var h =  e.n(y);
    // CONCATENATED MODULE: external "@splunk/react-ui/WaitSpinner"
    const b = require("@splunk/react-ui/WaitSpinner");
    var g =  e.n(b);
    // CONCATENATED MODULE: external "@splunk/themes"
    const S = require("@splunk/themes");
    // CONCATENATED MODULE: ./src/ResultsMenu/ResultsMenuStyles.ts
    var O = h().div.withConfig({
        displayName: "ResultsMenuStyles__Styled",
        componentId: "avbhl8-0"
    })([ "", ";flex-direction:column;max-height:calc(100vh - 20px);", "" ], S.mixins.reset("flex"), (0, 
    S.pick)({
        prisma: (0, y.css)([ "border-radius:", ";background-color:", ";" ], S.variables.borderRadius, S.variables.backgroundColorPopup)
    }));
    var E = h().div.withConfig({
        displayName: "ResultsMenuStyles__StyledFooter",
        componentId: "avbhl8-1"
    })([ "padding:", ";color:", ";", "" ], (0, S.pick)({
        prisma: {
            comfortable: "10px 16px",
            compact: "6px 16px"
        },
        enterprise: "6px 10px"
    }), (0, S.pick)({
        prisma: S.variables.contentColorMuted,
        enterprise: S.variables.textGray
    }), (function(e) {
        var t = e.$placement;
        return t === "above" ? (0, S.pick)({
            prisma: (0, y.css)([ "border-bottom:1px solid ", ";" ], S.variables.neutral200),
            enterprise: (0, y.css)([ "border-bottom:", ";" ], S.variables.border)
        }) : (0, S.pick)({
            prisma: (0, y.css)([ "border-top:1px solid ", ";" ], S.variables.neutral200),
            enterprise: (0, y.css)([ "border-top:", ";" ], S.variables.border)
        });
    }));
    var M = h().li.withConfig({
        displayName: "ResultsMenuStyles__StyledLoading",
        componentId: "avbhl8-2"
    })([ "", ";padding:", ";gap:", ";" ], S.mixins.reset("flex"), (0, S.pick)({
        prisma: {
            comfortable: "10px 16px",
            compact: "6px 16px"
        },
        enterprise: "6px 10px"
    }), S.variables.spacingXSmall);
    var w = h()(m()).withConfig({
        displayName: "ResultsMenuStyles__StyledMenu",
        componentId: "avbhl8-3"
    })([ "overflow:auto;flex-direction:column;" ]);
    var P = h()(g()).withConfig({
        displayName: "ResultsMenuStyles__StyledWait",
        componentId: "avbhl8-4"
    })([ "flex:0 0 auto;" ]);
    var x = h().div.withConfig({
        displayName: "ResultsMenuStyles__StyledLoadingMessage",
        componentId: "avbhl8-5"
    })([ "flex:1 0 0;color:", ";" ], (0, S.pick)({
        prisma: S.variables.contentColorMuted,
        enterprise: S.variables.textGray
    }));
    // CONCATENATED MODULE: ./src/utils/updateReactRef.ts
    /**
 * Updates a React ref. Callback refs and object refs (from `createRef` and `useRef`) are supported.
 *
 * @param ref - The React callback or object ref. Can be `null` or `undefined`.
 * @param current - The new value of the ref.
 */
    function j(e, t) {
        if (e) {
            if (typeof e === "function") {
                e(t);
            } else {
                // the public signature of this util uses React.Ref<T> to mirror the way React types refs.
                // the intention here is to signal "we will take care of setting 'current', not you".
                e.current = t;
 // eslint-disable-line no-param-reassign
                        }
        }
    }
    // CONCATENATED MODULE: ./src/ResultsMenu/ResultsMenu.tsx
    function k(e) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            k = function e(t) {
                return typeof t;
            };
        } else {
            k = function e(t) {
                return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            };
        }
        return k(e);
    }
    function I() {
        I = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var r = arguments[t];
                for (var n in r) {
                    if (Object.prototype.hasOwnProperty.call(r, n)) {
                        e[n] = r[n];
                    }
                }
            }
            return e;
        };
        return I.apply(this, arguments);
    }
    function R(e, t) {
        if (!(e instanceof t)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function T(e, t) {
        for (var r = 0; r < t.length; r++) {
            var n = t[r];
            n.enumerable = n.enumerable || false;
            n.configurable = true;
            if ("value" in n) n.writable = true;
            Object.defineProperty(e, n.key, n);
        }
    }
    function C(e, t, r) {
        if (t) T(e.prototype, t);
        if (r) T(e, r);
        return e;
    }
    function A(e, t) {
        if (typeof t !== "function" && t !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: true,
                configurable: true
            }
        });
        if (t) _(e, t);
    }
    function _(e, t) {
        _ = Object.setPrototypeOf || function e(t, r) {
            t.__proto__ = r;
            return t;
        };
        return _(e, t);
    }
    function K(e) {
        var t = H();
        return function r() {
            var n = q(e), o;
            if (t) {
                var i = q(this).constructor;
                o = Reflect.construct(n, arguments, i);
            } else {
                o = n.apply(this, arguments);
            }
            return L(this, o);
        };
    }
    function L(e, t) {
        if (t && (k(t) === "object" || typeof t === "function")) {
            return t;
        }
        return B(e);
    }
    function B(e) {
        if (e === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return e;
    }
    function H() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
            Date.prototype.toString.call(Reflect.construct(Date, [], (function() {})));
            return true;
        } catch (e) {
            return false;
        }
    }
    function q(e) {
        q = Object.setPrototypeOf ? Object.getPrototypeOf : function e(t) {
            return t.__proto__ || Object.getPrototypeOf(t);
        };
        return q(e);
    }
    function D(e, t, r) {
        if (t in e) {
            Object.defineProperty(e, t, {
                value: r,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            e[t] = r;
        }
        return e;
    }
    var F = {
        animateLoading: i().bool,
        children: i().node,
        /** @private */
        controlledExternally: i().bool,
        childrenStart: i().node,
        elementRef: i().oneOfType([ i().func, i().object ]),
        footerMessage: i().node,
        isLoading: i().bool,
        loadingMessage: i().node,
        noOptionsMessage: i().node,
        /** @private */
        onDownKeyPress: i().func,
        /** @private */
        onEndKeyPress: i().func,
        /** @private */
        onHomeKeyPress: i().func,
        onScroll: i().func,
        onScrollBottom: i().func,
        /** @private */
        onUpKeyPress: i().func,
        placement: i().string,
        menuId: i().string
    };
    var N = {
        animateLoading: false,
        isLoading: false,
        loadingMessage: (0, d._)("Loading..."),
        noOptionsMessage: (0, d._)("No matches")
    };
    var U = {
        role: "listbox"
    };
    var z = c()((function(e) {
        return {
            height: e
        };
    }));
    // @docs-props-type ResultsMenuPropsBase
        var W =  function(e) {
        A(o, e);
        var t = K(o);
        function o(e) {
            var n;
            R(this, o);
            n = t.call(this, e);
            D(B(n), "scrollBottomOffset", void 0);
            D(B(n), "itemMinHeight", void 0);
            D(B(n), "handleMenuMount", (function(e) {
                n.setState({
                    menuEl: e
                });
            }));
            D(B(n), "handleMount", (function(e) {
                n.setState({
                    containerEl: e
                });
                j(n.props.elementRef, e);
            }));
            D(B(n), "handleMouseEnter", (function() {
                n.setState({
                    windowTop: document.documentElement.scrollTop
                });
            }));
            D(B(n), "handleMouseLeave", (function() {
                n.setState({
                    windowTop: document.documentElement.scrollTop
                });
            }));
            D(B(n), "handleScroll", (function(e) {
                var t, r;
                if (n.props.onScrollBottom != null) {
                    if (e.target && n.state.menuEl) {
                        var o = n.state.menuEl.scrollHeight - n.state.menuEl.offsetHeight - n.scrollBottomOffset;
 // Adding 1 due to border of menu item.
                                                if (n.state.menuEl.scrollTop + 1 >= o) {
                            n.handleScrollBottom(e);
                        }
                    }
                }
                (t = (r = n.props).onScroll) === null || t === void 0 ? void 0 : t.call(r, e);
            }));
            D(B(n), "handleWheelMenu", (function(e) {
                // Safety net to ensure window doesn't scroll if menu is scrolled pass the numberOfItemsLoaded at high velocity.
                e.stopPropagation();
                document.documentElement.scrollTop = n.state.windowTop;
            }));
            D(B(n), "handleScrollBottomOnFullMenu", (function() {
                var e = r.Children.count(n.props.children);
                var t = n.state.childrenCount;
 // If menu is full length, load more items.
                                if (n.checkFullHeight()) {
                    n.handleScrollBottom(null);
                }
 // avoid triggering this logic if this.state.childrenCount is null
                // because that's not a real change in the number of children
                // and thus we want to avoid resetting the value of scrollBottomTriggered
                                if (t != null && e !== t) {
                    n.setState({
                        numberOfItemsLoaded: e - (t !== null && t !== void 0 ? t : 0),
                        scrollBottomTriggered: false
                    });
                }
                if (e !== t) {
                    n.setState({
                        childrenCount: e
                    });
                }
            }));
            n.state = {
                containerEl: null,
                menuEl: null,
                numberOfItemsLoaded: 0,
                scrollBottomTriggered: false,
                windowTop: 0
            };
 // The remaining amount of pixels when scrolled from bottom of menu to trigger onScrollBottom().
                        n.scrollBottomOffset = 400;
            n.itemMinHeight = 28;
            return n;
        }
        C(o, [ {
            key: "componentDidUpdate",
            value: function e() {
                var t, r;
                var n = this.state, o = n.containerEl, i = n.menuEl;
                if (!p.isIE11 || !o || !i) {
                    return;
                }
 // If onScrollBottom is defined, determine if it should be triggered.
                                if (((t = this.props) === null || t === void 0 ? void 0 : t.onScrollBottom) && ((r = this.props) === null || r === void 0 ? void 0 : r.children)) {
                    this.handleScrollBottomOnFullMenu();
                }
            }
        }, {
            key: "handleScrollBottom",
            value: function e(t) {
                // Prevent multiple calls to onScrollBottom.
                if (!this.state.scrollBottomTriggered) {
                    var r, n;
                    this.setState({
                        scrollBottomTriggered: true
                    });
                    (r = (n = this.props).onScrollBottom) === null || r === void 0 ? void 0 : r.call(n, t);
                }
            }
        }, {
            key: "checkFullHeight",
            value: function e() {
                var t = this.state.menuEl;
                return t && t.scrollHeight === t.offsetHeight;
            }
        }, {
            key: "renderFooterMessage",
            value: function e() {
                return this.props.footerMessage && !!r.Children.toArray(this.props.children).length &&  n().createElement(E, {
                    $placement: this.props.placement,
                    "data-test": "footer-message",
                    key: "footer"
                }, this.props.footerMessage);
            }
        }, {
            key: "render",
            value: function e() {
                var t = this.props, i = t.animateLoading, u = t.children, l = t.controlledExternally, c = t.childrenStart, s = t.isLoading, d = t.loadingMessage, p = t.noOptionsMessage, y = t.onDownKeyPress, h = t.onEndKeyPress, b = t.onHomeKeyPress, g = t.onScrollBottom, S = t.onUpKeyPress, E = t.placement, j = t.style, k = t.tabIndex, R = t.menuId, T = t["aria-multiselectable"];
                var C = f()(this.props, a()(o.propTypes));
                // Assumption: that you cannot be filtered if you are a result
                                var A = r.Children.toArray(u).filter(r.isValidElement).some((function(e) {
                    var t = e.type;
                    return !(t === v.Divider && t.filterFirst || (t === v.Divider || t === v.Heading) && (t.filterLast || t.filterConsecutive));
                }));
                var _ = this.checkFullHeight();
                var K = z(this.state.scrollBottomTriggered ? this.state.numberOfItemsLoaded * this.itemMinHeight || 0 : 0);
                /* eslint-disable jsx-a11y/aria-role */                
                return n().createElement(O, I({
                    key: "wrapper",
                    ref: this.handleMount,
                    onWheel: g ? this.handleWheelMenu : undefined,
                    onMouseEnter: g ? this.handleMouseEnter : undefined,
                    onMouseLeave: g ? this.handleMouseLeave : undefined
                }, f()(C, "tabIndex", "aria-multiselectable", "menuId"), {
                    style: j
                }), E !== "above" && c, E === "above" && this.renderFooterMessage(),  n().createElement(v.MenuContext.Provider, {
                    value: U
                },  n().createElement(w, {
                    key: "menu",
                    controlledExternally: l,
                    elementRef: this.handleMenuMount,
                    onDownKeyPress: y,
                    onEndKeyPress: h,
                    onHomeKeyPress: b,
                    onScroll: this.handleScroll,
                    onUpKeyPress: S,
                    stopScrollPropagation: true,
                    tabIndex: k,
                    "aria-multiselectable": T,
                    id: R
                }, !A && p && !s &&  n().createElement(m().Item, {
                    "data-test": "no-results-message",
                    disabled: true
                }, p), u, g && !_ && 
                
                // Bottom spacer fills in the space of new items being loaded by using the minimum possible height x menuItems.
                n().createElement("div", {
                    "data-test": "results-menu-bottom-spacer",
                    style: K
                }), s &&  n().createElement(M, null, i &&  n().createElement(P, null),  n().createElement(x, null, d)))), E !== "above" && this.renderFooterMessage(), E === "above" && c);
            }
        } ]);
        return o;
    }(r.Component);
    D(W, "propTypes", F);
    D(W, "defaultProps", N);
    /* harmony default export */    const $ = W;
    // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/groupChildren.ts
    // Cheap(er than processing potentially thousands of array elements) memoization
    var G = {
        result: []
    };
    /**
 * Given component children, restructure them into an array of arrays, each of length `groupSize`.
 *
 * The last array is not guaranteed to be full, it will have a length in the range `[1, groupSize]`
 *
 * @example
 * ```js
 * groupChildren([1, 2, 3, 4, 5, 6, 7], 2);
 * // > [[1, 2], [3, 4], [5, 6], [7]]
 * ```
 * @param {Array} children One node, or an array of nodes, to be divided into groups
 * @param {number} groupSize The size of each group to be created
 * @returns A 2d array where each inner-array is a group of size `groupSize` of children
 * and the order of the `children` received equals the order of the flattened result
 */    var V = function e(t, n) {
        if (G.children === t && G.groupSize === n) {
            return G.result;
        }
        G.children = t;
        G.groupSize = n;
        if (n <= 1) {
            if (false) {}
 // don't break in non-__DEV__ and return one big group
                        G.result = [ r.Children.toArray(t) ];
        } else {
            G.result = r.Children.toArray(t).reduce((function(e, t, r) {
                var o = Math.floor(r / n);
                if (!Array.isArray(e[o])) {
                    // eslint-disable-next-line no-param-reassign
                    e[o] = [];
                }
                e[o].push(t);
                return e;
            }), []);
        }
        return G.result;
    };
    // CONCATENATED MODULE: external "@splunk/ui-utils/id"
    const X = require("@splunk/ui-utils/id");
    // CONCATENATED MODULE: ./src/utils/getMenuChildNode.tsx
    // TODO(SUI-5919): fix the ref handling in the other components so this isn't needed
    /**
 * @private Get the HTML <anchor> or <button> node for a received derivative of Menu.Item
 */
    var J = function e(t) {
        var r, n, o, i;
        if (t.el) {
            return t.el;
 // Menu.Item
                }
        if ((r = t.c) === null || r === void 0 ? void 0 : r.el) {
            return t.c.el;
 // Multiselect.Option
                }
        if ((n = t.c) === null || n === void 0 ? void 0 : (o = n.c) === null || o === void 0 ? void 0 : o.el) {
            return t.c.c.el;
 // Select.Option
                }
        if ((i = t.item) === null || i === void 0 ? void 0 : i.el) {
            return t.item.el;
 // ComboBox.Option
                }
        return null;
    };
    // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/VirtualizedItem.ts
    function Q(e, t) {
        return re(e) || te(e, t) || Z(e, t) || Y();
    }
    function Y() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function Z(e, t) {
        if (!e) return;
        if (typeof e === "string") return ee(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        if (r === "Object" && e.constructor) r = e.constructor.name;
        if (r === "Map" || r === "Set") return Array.from(e);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return ee(e, t);
    }
    function ee(e, t) {
        if (t == null || t > e.length) t = e.length;
        for (var r = 0, n = new Array(t); r < t; r++) {
            n[r] = e[r];
        }
        return n;
    }
    function te(e, t) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(e))) return;
        var r = [];
        var n = true;
        var o = false;
        var i = undefined;
        try {
            for (var u = e[Symbol.iterator](), a; !(n = (a = u.next()).done); n = true) {
                r.push(a.value);
                if (t && r.length === t) break;
            }
        } catch (e) {
            o = true;
            i = e;
        } finally {
            try {
                if (!n && u["return"] != null) u["return"]();
            } finally {
                if (o) throw i;
            }
        }
        return r;
    }
    function re(e) {
        if (Array.isArray(e)) return e;
    }
    var ne = {
        children: i().node,
        onMount: i().func.isRequired,
        onUnmount: i().func.isRequired
    };
    /** @private Used by `VirtualizedResultsMenu` */    var oe =  n().forwardRef((function(e, t) {
        var n = e.children, o = e.onMount, i = e.onUnmount;
        var u = (0, r.useState)(), a = Q(u, 2), l = a[0], c = a[1];
        (0, r.useEffect)((function() {
            if (l) {
                o(l);
            }
            return function() {
                if (l) {
                    i(l);
                }
            };
        }), [ l, o, i ]);
        var s = r.Children.only(n);
        if (!s) {
            if (false) {}
            return null;
        }
        
        return (0, r.cloneElement)(s, {
            ref: function e(r) {
                var n = r;
                if (!n) {
                    return;
                }
                j(t, r);
                j(c, J(n));
            }
        });
    }));
    oe.propTypes = ne;
    oe.as = "Item";
    // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/injectVirtualizedItem.tsx
    /**
 * Find the index of an array element which is nearest to targetIndex and is a Menu.Item component
 * @param {Array} elements An array to search
 * @param {Number} targetIndex The target index. This is the ideal value to return.
 * @returns The index in the array of the nearest `Menu.Item` component to `targetIndex`, or -1 if no element is a `Menu.Item` component
 */
    var ie = function e(t, r) {
        var n = -1;
        var o = -1;
        t.forEach((function(e, t) {
            var i = Math.abs(r - t);
            if (n >= 0 && n < i) {
                return;
            }
            if (e.type !== v.Divider && e.type !== v.Heading) {
                n = i;
                o = t;
            }
        }));
        return o;
    };
    /**
 * @private Keep the injection of `VirtualizedItem` DRY. Will always replace the middle-most non-divider/heading
 * with a VirtualizedItem instance.
 * - If `trackFirstElement` the **FIRST** non-divider/heading item will also be replaced.
 * - If `trackLastElement` the **LAST** non-divider/heading item will also be replaced.
 */    var ue = function e(t, r, o) {
        var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}, u = i.trackFirstElement, a = i.trackLastElement;
        if (!Array.isArray(t)) {
            return [];
        }
        var l = ie(t, Math.floor(t.length / 2));
        var c = u && ie(t, 0);
        var s = a && ie(t, t.length - 1);
        return t.map((function(e, t) {
            if (t === l || t === c || t === s) {
                
                return n().createElement(oe, {
                    key: (0, X.createGUID)(),
                    onMount: r,
                    onUnmount: o
                }, e);
            }
            return e;
        }));
    };
    // CONCATENATED MODULE: ./src/utils/navigateList.ts
    // A utility for keyboard navigation of lists
    function ae(e, t, r) {
        for (var n = 0; n < e.length; n += 1) {
            var o;
            var i = (n + r) % e.length;
            if (((o = e[i].current) === null || o === void 0 ? void 0 : o.props.disabled) !== true) {
                return e[i];
            }
        }
        return e[t];
    }
    function le(e, t, r) {
        for (var n = e.length; n > 0; n -= 1) {
            var o;
            var i = (n + r) % e.length;
            if (((o = e[i].current) === null || o === void 0 ? void 0 : o.props.disabled) !== true) {
                return e[i];
            }
        }
        return e[t];
    }
    // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/VirtualizedResultsMenu.tsx
    function ce() {
        ce = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var r = arguments[t];
                for (var n in r) {
                    if (Object.prototype.hasOwnProperty.call(r, n)) {
                        e[n] = r[n];
                    }
                }
            }
            return e;
        };
        return ce.apply(this, arguments);
    }
    function se(e) {
        return pe(e) || de(e) || ye(e) || fe();
    }
    function fe() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function de(e) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(e)) return Array.from(e);
    }
    function pe(e) {
        if (Array.isArray(e)) return he(e);
    }
    function ve(e, t) {
        return ge(e) || be(e, t) || ye(e, t) || me();
    }
    function me() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function ye(e, t) {
        if (!e) return;
        if (typeof e === "string") return he(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        if (r === "Object" && e.constructor) r = e.constructor.name;
        if (r === "Map" || r === "Set") return Array.from(e);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return he(e, t);
    }
    function he(e, t) {
        if (t == null || t > e.length) t = e.length;
        for (var r = 0, n = new Array(t); r < t; r++) {
            n[r] = e[r];
        }
        return n;
    }
    function be(e, t) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(e))) return;
        var r = [];
        var n = true;
        var o = false;
        var i = undefined;
        try {
            for (var u = e[Symbol.iterator](), a; !(n = (a = u.next()).done); n = true) {
                r.push(a.value);
                if (t && r.length === t) break;
            }
        } catch (e) {
            o = true;
            i = e;
        } finally {
            try {
                if (!n && u["return"] != null) u["return"]();
            } finally {
                if (o) throw i;
            }
        }
        return r;
    }
    function ge(e) {
        if (Array.isArray(e)) return e;
    }
    function Se(e, t) {
        if (e == null) return {};
        var r = Oe(e, t);
        var n, o;
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            for (o = 0; o < i.length; o++) {
                n = i[o];
                if (t.indexOf(n) >= 0) continue;
                if (!Object.prototype.propertyIsEnumerable.call(e, n)) continue;
                r[n] = e[n];
            }
        }
        return r;
    }
    function Oe(e, t) {
        if (e == null) return {};
        var r = {};
        var n = Object.keys(e);
        var o, i;
        for (i = 0; i < n.length; i++) {
            o = n[i];
            if (t.indexOf(o) >= 0) continue;
            r[o] = e[o];
        }
        return r;
    }
    function Ee(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            if (t) n = n.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            }));
            r.push.apply(r, n);
        }
        return r;
    }
    function Me(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = arguments[t] != null ? arguments[t] : {};
            if (t % 2) {
                Ee(Object(r), true).forEach((function(t) {
                    we(e, t, r[t]);
                }));
            } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(e, Object.getOwnPropertyDescriptors(r));
            } else {
                Ee(Object(r)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
                }));
            }
        }
        return e;
    }
    function we(e, t, r) {
        if (t in e) {
            Object.defineProperty(e, t, {
                value: r,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            e[t] = r;
        }
        return e;
    }
    var Pe = Me(Me({}, f()(F, "onDownKeyPress", "onEndKeyPress", "onHomeKeyPress", "onUpKeyPress")), {}, {
        virtualization: i().number.isRequired
    });
    var xe = {
        virtualization: 0
    };
    var je = [];
    var ke = function e(t, r) {
        var n = r.itemRefs, o = r.focusedItemKey;
        var i = ae(n, o, o + 1);
        return [ n.indexOf(i) < o ? o : i, false ];
    };
    var Ie = function e(t, r) {
        var n = r.itemRefs, o = r.focusedItemKey;
        var i = le(n, o, o - 1);
        return [ n.indexOf(i) > o ? o : i, false ];
    };
    /**
 * A wrapper for `ResultsMenu` which virtualizes the `children`. The received `children` array will be split into **"panes"** each with `virtualization` entries
 * and, at any given time, 3 or fewer of these panes will be rendered in the DOM.
 *
 * Given the children `[1, 2, 3, 4, 5, 6, 7, 8, 9]` and `virtualization=4`, then at first only elements `[1, 2, 3, 4, 5, 6, 7, 8]` will be added to the DOM.
 * Once either child `6` or `8` intersect the `Menu` rendered by `ResultsMenu` the next pane of children will also be included and, if needed, the oldest pane
 * will be removed.
 *
 * In effect this means the menu will show the "central" content at pane index _`n`_, a previous-content-buffer comprised of pane index _`n - 1`_,
 * and an upcoming-content-buffer comprised of pane index _`n + 1`_.
 *
 * An `IntersectionObserver` will observe the first node in the _`n - 1`_ pane, the last node in the _`n + 1`_ pane, and the central node in both _`n ± 1`_ panes
 * for intersections with the rendered `Menu` and trigger a *pane change* upon that intersection. As such, in SSR or other environments which don't support `IntersectionObserver`
 * this component should not be used and will be replaced by the barrel file with a vanilla `ResultsMenu`.
 *
 * @throws in `__DEV__` when `virtualization` is too small as compared to the menu height (`virtualization` must be greater than the number of visible items in the rendered menu)
 * @throws in `__DEV__` when `virtualization` is less than or equal to 1 (`virtualization` must be ≥ 2)
 * @throws in `__DEV__` when `virtualization` is changed during the lifecycle of the `VirtualizedResultsMenu` component
 */    function Re(e) {
        var t = e.virtualization, o = e.elementRef, i = e.children, u = Se(e, [ "virtualization", "elementRef", "children" ]);
        // @docs-props-type VirtualizedResultsMenuPropsBase
        // If a user tries to set virtualization to a value smaller than the number of options
        // visible at a given moment then the menu will flicker endlessly. This state is set in
        // the IntersectionObserver to fix the issue, but in `__DEV__` an error is thrown.
                var a = (0, r.useState)(t), l = ve(a, 2), c = l[0], s = l[1];
 // `useRef` will recompute its initial value every render cycle.
        // To avoid the array processing we can provide an initialization function to useState and init the ref with the result
                var f = (0, r.useState)((function() {
            return V(i, c);
        })), d = ve(f, 1), p = d[0];
 // NOSONAR
        // `windowPanes` is an array of arrays, each of length `virtualization`. Each "pane" is just a subset of
        // `children` which will be rendered in a chunk, and at most 3 of these panes will render at any given time.
                var v = (0, r.useRef)(p);
        var m = (0, r.useRef)(0);
 // An IntersectionObserver is used to detect when pane changes are needed.
        // When loadPrevPaneRef or loadNextPaneRef entries intersect the menu, the currentPaneId will be updated.
                var y = (0, r.useRef)();
        var h = (0, r.useRef)(je);
        var b = (0, r.useRef)(je);
        var g = (0, r.useCallback)((function() {
            var e;
            var t = v.current, r = t === void 0 ? [] : t;
            var n = m.current;
            /**
     * create onMount for an child of the menu which will be used to trigger pane
     * changes upon intersection with the menu's visible bounds
     */            var o = function e(t) {
                return function(e) {
                    var r;
                    if (!e) {
                        return;
                    }
                    t.current.push(e);
                    (r = y.current) === null || r === void 0 ? void 0 : r.observe(e);
                };
            };
            /**
     * onUnmount to cleanup the operations of `onVirtualizeMount`
     */            var i = function e(t) {
                var r;
                if (!t) {
                    return;
                }
                var n = b.current.indexOf(t);
                if (n >= 0) {
                    b.current.splice(n, 1);
                }
                var o = h.current.indexOf(t);
                if (o) {
                    h.current.splice(o, 1);
                }
                (r = y.current) === null || r === void 0 ? void 0 : r.unobserve(t);
            };
            return [].concat(se(ue(r[n - 1], o(b), i, {
                trackFirstElement: true
            })), se((e = r[n]) !== null && e !== void 0 ? e : []), se(ue(r[n + 1], o(h), i, {
                trackLastElement: true
            })));
        }), []);
        var S = (0, r.useState)(g), O = ve(S, 2), E = O[0], M = O[1];
        var w = (0, r.useCallback)((function(e) {
            var t = m.current;
            m.current = Math.max(0, Math.min(e, v.current.length - 1));
            if (t === m.current) {
                // no change in current pane
                return;
            }
            M(g);
        }), [ g ]);
 // Link an IntersectionObserver instance with the menu children to be observed
                var P = (0, r.useCallback)((function(e) {
            var t;
            j(o, e);
 // This is overly defensive and could probably be removed
                        (t = y.current) === null || t === void 0 ? void 0 : t.disconnect();
            if (!e) {
                return;
            }
            b.current = [];
            h.current = [];
 // Run the observation flow
                        y.current = new IntersectionObserver((function(t) {
                var r;
                var n = m.current;
                var o = e.firstElementChild;
                if (!!o && o.scrollHeight < e.clientHeight) {
                    var i;
                    // If the first element doesn't require a scrollbar then it's likely a filter input
                                        o = (i = o) === null || i === void 0 ? void 0 : i.nextElementSibling;
                }
                if (((r = o) === null || r === void 0 ? void 0 : r.scrollTop) === 0 && n === 0 && v.current.length > 1 && t.some((function(e) {
                    return e.isIntersecting;
                }))) {
                    // The menu hasn't scrolled, is on pane 0, and already has an intersection, the `virtualization` prop is too small
                    s((function(e) {
                        return e + 10;
                    }));
                    if (false) {}
                    return;
                }
                var u = false;
                t.forEach((function(e) {
                    if (u || !e.isIntersecting) {
                        // don't process if the pane changed or the entry isn't intersecting
                        return;
                    }
                    if (b.current.includes(e.target)) {
                        u = true;
                        w(n - 1);
                    } else if (h.current.includes(e.target)) {
                        u = true;
                        w(n + 1);
                    }
                }));
            }), {
                root: e
            });
        }), [ o, w ]);
        var x = (0, r.useCallback)((function(e, t) {
            var r, n;
            var o = t.itemRefs;
            var i = v.current.length - 1;
            if (m.current === i) {
                return [ le(o, o.length - 1, o.length - 1), true ];
            }
            w(i);
 // When we are rendering the last set of records a buffer will exist containing the next-to-last pane.
            // This means the desired index for focus will be the length of the buffer + the length of the last set
            // of records (less 1 because of array indexing)
                        var u = (r = v.current[i - 1].length) !== null && r !== void 0 ? r : 0;
            var a = v.current[i].length;
 // If the last child is non-interactive (Heading or Divider) then `Menu` will focus on the "next" interactive
            // element, which would be at the _start_ of the list. The IntersectionObserver would then change to the
            // `lastPaneId - 1` pane and the focus would be incorrect. Call `findClosestMenuItem` to avoid that.
                        var l = Math.max(u + a - 1, 0);
            var c = ie([].concat(se((n = v.current[i - 1]) !== null && n !== void 0 ? n : []), se(v.current[i])), l);
            return [ c, true ];
        }), [ w ]);
        var k = (0, r.useCallback)((function(e, t) {
            var r = t.itemRefs;
            if (m.current === 0) {
                return [ ae(r, 0, 0), true ];
            }
            w(0);
            return [ 0, true ];
        }), [ w ]);
        (0, r.useEffect)((function() {
            s((function(e) {
                if (false) {}
                return t;
            }));
        }), [ t ]);
        (0, r.useEffect)((function() {
            v.current = V(i, c);
            M(g);
        }), [ i, c, g ]);
        (0, r.useEffect)((function() {
            return function() {
                var e;
                return (e = y.current) === null || e === void 0 ? void 0 : e.disconnect();
            };
        }), []);
        
        return n().createElement($, ce({
            elementRef: P
        }, u, {
            onEndKeyPress: x,
            onHomeKeyPress: k,
            onUpKeyPress: Ie,
            onDownKeyPress: ke
        }), E);
    }
    Re.propTypes = Pe;
    Re.defaultProps = xe;
    // CONCATENATED MODULE: ./src/utils/ssrDocument.ts
    /* eslint-disable @typescript-eslint/no-empty-function */
    var Te = {
        body: {
            appendChild: function e() {
                return [];
            }
        },
        addEventListener: function e() {},
        removeEventListener: function e() {},
        activeElement: {
            blur: function e() {},
            nodeName: ""
        },
        querySelector: function e() {
            return null;
        },
        querySelectorAll: function e() {
            return [];
        },
        getElementById: function e() {
            return null;
        },
        createEvent: function e() {
            return {
                initEvent: function e() {}
            };
        },
        createElement: function e() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute: function e() {},
                getElementsByTagName: function e() {
                    return [];
                }
            };
        },
        createElementNS: function e() {
            return {};
        },
        importNode: function e() {
            return null;
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };
    function Ce() {
        var e = typeof document !== "undefined" ? document : Te;
        return e;
    }
    // CONCATENATED MODULE: ./src/utils/ssrWindow.ts
    /* eslint-disable @typescript-eslint/no-empty-function */
    var Ae = {
        document: Te,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState: function e() {},
            pushState: function e() {},
            go: function e() {},
            back: function e() {}
        },
        CustomEvent: function e() {
            return this;
        },
        addEventListener: function e() {},
        removeEventListener: function e() {},
        getComputedStyle: function e() {
            return {
                getPropertyValue: function e() {
                    return "";
                }
            };
        },
        Image: function e() {},
        Date: function e() {},
        screen: {},
        setTimeout: function e() {},
        clearTimeout: function e() {},
        matchMedia: function e() {
            return {};
        },
        requestAnimationFrame: function e(t) {
            if (typeof setTimeout === "undefined") {
                t();
                return null;
            }
            return setTimeout(t, 0);
        },
        cancelAnimationFrame: function e(t) {
            if (typeof setTimeout === "undefined") {
                return;
            }
            clearTimeout(t);
        }
    };
    function _e() {
        var e = typeof window !== "undefined" ? window : Ae;
        return e;
    }
    // CONCATENATED MODULE: ./src/ResultsMenu/VirtualizedResultsMenu/index.ts
    // In environments without IntersectionObserver support this should just export ResultsMenu
    var Ke = "IntersectionObserver" in _e() ? Re : $;
    /* harmony default export */    const Le = Ke;
    // CONCATENATED MODULE: ./src/ResultsMenu/index.ts
    module.exports = t;
    /******/})();