import React, { Component } from 'react';
import { ClassComponentProps } from '../utils/types';
interface ScrollPropsBase {
    children?: React.ReactNode;
    /**
     * A React ref which is set to the DOM element when the component mounts and null when it unmounts.
     */
    elementRef?: React.Ref<Element>;
    /** A callback for when an animated update completes. Ensure the animate prop is set back to
     * false and return control to the user. */
    onScrollComplete?: () => void;
    /** A callback for when the scroll position changes. */
    onScroll?: React.UIEventHandler<Element>;
    /** Set this to animate to a specific scroll position. Remove this property onScrollComplete to
         restore control to the user. */
    top?: number;
    /** Set this to animate to a specific scroll position. Remove this property onScrollComplete to
         restore control to the user. */
    left?: number;
    /** Prevent mouseWheel events from scrolling the page or other containers. 'window' only
     * stops the window from scrolling by removing the scroll bars, which has better performance
     * but can affect layout. */
    stopScrollPropagation?: boolean | 'window';
    tagName?: keyof JSX.IntrinsicElements;
}
declare const defaultProps: Required<Pick<ScrollPropsBase, 'stopScrollPropagation' | 'tagName'>>;
type ScrollProps = ClassComponentProps<ScrollPropsBase, typeof defaultProps, keyof JSX.IntrinsicElements>;
interface ScrollState {
    currentLeft: number;
    currentTop: number;
}
declare class Scroll extends Component<ScrollProps, ScrollState> {
    static propTypes: React.WeakValidationMap<ScrollProps>;
    static defaultProps: Required<Pick<ScrollPropsBase, "tagName" | "stopScrollPropagation">>;
    constructor(props: Readonly<ScrollProps>);
    private handleRest;
    private handleScroll;
    private renderInner;
    render(): JSX.Element;
}
export default Scroll;
