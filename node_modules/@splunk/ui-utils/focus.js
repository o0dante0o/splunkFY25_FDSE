"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSortedTabbableElements = getSortedTabbableElements;
exports.isTabKey = isTabKey;
exports.handleTab = handleTab;
exports.takeFocus = takeFocus;

var _keyboard = require("@splunk/ui-utils/keyboard");

var _defer = _interopRequireDefault(require("lodash/defer"));

var _filter = _interopRequireDefault(require("lodash/filter"));

var _sortBy = _interopRequireDefault(require("lodash/sortBy"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @file
 * Utilities for managing focus in the browser.
 */
var tabbableSelectors = ['a[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', '[contenteditable]'];
var tabbableSelectorsWithTabIndex = tabbableSelectors.concat(['[tabindex]']);

var isHidden = function isHidden(element) {
  return !(element.offsetWidth || element.offsetHeight || element.getClientRects().length > 0) || getComputedStyle(element).visibility === 'hidden';
};
/**
 * Sorts the tabbable elements in the provided container.
 *
 * @param {Element} container - The target container.
 * @param {Object} options
 * If set, will neither use "tabindex" as an indicator of selectability nor disqualify elements based on "tabindex=-1"
 * @param {boolean} options.ignoreTabIndex
 * @returns {Element[]}
 * @public
 */


function getSortedTabbableElements(container) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      ignoreTabIndex = _ref.ignoreTabIndex;

  var tabbableElementSelector = (ignoreTabIndex ? tabbableSelectors : tabbableSelectorsWithTabIndex).join(', ');
  var elems = container.querySelectorAll(tabbableElementSelector);
  var tabbableElems = (0, _filter["default"])(elems, function (el) {
    return !isHidden(el) && (ignoreTabIndex || el.tabIndex >= 0) || el === document.activeElement;
  });
  var reducedElements = tabbableElems.reduce(function (accumulator, currentElement) {
    var prevElement = accumulator[accumulator.length - 1];
    var isPrevElementRadio = (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('type')) === 'radio';
    var isCurrElementRadio = currentElement.getAttribute('type') === 'radio';
    var sameRadioGroup = currentElement.getAttribute('name') === (prevElement === null || prevElement === void 0 ? void 0 : prevElement.getAttribute('name')); // Reduce radio elements to a single Tab stop, ensuring only one per group is focusable

    if (isPrevElementRadio && isCurrElementRadio && sameRadioGroup) {
      if (currentElement.checked) {
        // replace previous radio with current checked radio
        accumulator.pop();
        accumulator.push(currentElement);
      }
    } else {
      accumulator.push(currentElement);
    }

    return accumulator;
  }, []);
  return (0, _sortBy["default"])(reducedElements, function (el) {
    if (el.tabIndex > 0) {
      return -1 / el.tabIndex;
    }

    return 0;
  });
}

function isTabKey(event) {
  return !((0, _keyboard.keycode)(event) !== 'tab' || event.metaKey || event.altKey || event.controlKey);
}
/**
 * A key event handler that moves focus among tabbable elements within a container.
 *
 * @param {Element} container - The target container.
 * @param {Event} event - The key event to handle.
 * @returns {Element|null} The element focus was applied to or `null` if focus was not applied.
 * @public
 */


function handleTab(container, event) {
  // Ignore events bubbling up from portals
  if (!container.contains(document.activeElement)) {
    return null;
  } // Ensure this is a valid event


  if (!isTabKey(event)) {
    return null;
  }

  var tabbableElements = getSortedTabbableElements(container);

  if (tabbableElements.length === 0) {
    // if the container is focused, don't allow the focus to leave.
    if (document.activeElement === container) {
      event.preventDefault();
      return container;
    }

    return null;
  } // Find the current index or set default.


  var currentElement = event && event.target || container.querySelector(':focus');
  var currentIndex = tabbableElements.indexOf(currentElement);

  if (currentIndex === -1) {
    currentIndex = event.shiftKey ? 0 : tabbableElements.length - 1;
  } // Shift the array instead of the current index.


  if (event.shiftKey) {
    tabbableElements.unshift(tabbableElements.pop()); // move last to first
  } else {
    tabbableElements.push(tabbableElements.shift()); // move first to last
  } // Focus


  event.preventDefault();
  tabbableElements[currentIndex].focus();
  return tabbableElements[currentIndex];
}
/**
 * A helper method that focuses on the first focusable element in a container.
 * If a contained element already has focus, focus does not shift.
 *
 * @param {Element} container - The container that takes focus.
 * @param {String} [defaultElement='first'] - The target of focus, either 'first' or 'container'.
 * @returns {Element|null} The element that was focused, or null if no element was focused.
 * @public
 */


function takeFocus(container) {
  var defaultElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'first';
  var currentElement = container.querySelector(':focus');

  if (currentElement) {
    return currentElement;
  }

  if (defaultElement === 'first') {
    var targetEl = getSortedTabbableElements(container)[0];

    if (targetEl) {
      (0, _defer["default"])(function () {
        return targetEl.focus();
      });
      return targetEl;
    }
  }

  if (container.hasAttribute('tabIndex')) {
    (0, _defer["default"])(function () {
      return container.focus();
    });
    return container;
  }

  return null;
}